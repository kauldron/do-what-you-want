package com.lockwood.automata.android

import android.accounts.AccountManager
import android.app.*
import android.app.admin.DevicePolicyManager
import android.app.job.JobScheduler
import android.app.usage.UsageStatsManager
import android.appwidget.AppWidgetManager
import android.bluetooth.BluetoothManager
import android.content.ClipboardManager
import android.content.Context
import android.content.Intent
import android.content.RestrictionsManager
import android.content.pm.LauncherApps
import android.content.res.ColorStateList
import android.graphics.drawable.Drawable
import android.hardware.ConsumerIrManager
import android.hardware.SensorManager
import android.hardware.camera2.CameraManager
import android.hardware.display.DisplayManager
import android.hardware.input.InputManager
import android.hardware.usb.UsbManager
import android.location.LocationManager
import android.media.AudioManager
import android.media.MediaRouter
import android.media.projection.MediaProjectionManager
import android.media.session.MediaSessionManager
import android.media.tv.TvInputManager
import android.net.ConnectivityManager
import android.net.nsd.NsdManager
import android.net.wifi.WifiManager
import android.net.wifi.p2p.WifiP2pManager
import android.nfc.NfcManager
import android.os.*
import android.os.storage.StorageManager
import android.print.PrintManager
import android.telecom.TelecomManager
import android.telephony.SubscriptionManager
import android.telephony.TelephonyManager
import android.util.Log
import android.util.TypedValue
import android.view.LayoutInflater
import android.view.WindowManager
import android.view.accessibility.AccessibilityManager
import android.view.accessibility.CaptioningManager
import android.view.inputmethod.InputMethodManager
import android.view.textservice.TextServicesManager
import androidx.annotation.ColorInt
import androidx.annotation.ColorRes
import androidx.annotation.DrawableRes
import java.io.File
import java.util.*
import java.util.concurrent.Executor
import java.util.concurrent.RejectedExecutionException

open class ContextCompat
/**
 * This class should not be instantiated, but the constructor must be
 * visible for the class to be extended (ex. in ActivityCompat).
 */
protected constructor() {


    /** Nested class provides lazy initialization only when needed.  */

    companion object {

        private const val TAG = "ContextCompat"
        private val sLock = Any()
        private var sTempValue: TypedValue? = null


        /**
         * Returns a drawable object associated with a particular resource ID.
         *
         *
         * Starting in [android.os.Build.VERSION_CODES.LOLLIPOP], the
         * returned drawable will be styled for the specified Context's theme.
         *
         * @param id The desired resource identifier, as generated by the aapt tool.
         * This integer encodes the package, type, and resource entry.
         * The value 0 is an invalid identifier.
         * @return Drawable An object that can be used to draw this resource.
         */
        fun getDrawable(context: Context, @DrawableRes id: Int): Drawable? {
            return if (Build.VERSION.SDK_INT >= 21) {
                context.getDrawable(id)
            } else
                context.resources.getDrawable(id)
        }

        /**
         * Returns a color state list associated with a particular resource ID.
         *
         *
         * Starting in [android.os.Build.VERSION_CODES.M], the returned
         * color state list will be styled for the specified Context's theme.
         *
         * @param id The desired resource identifier, as generated by the aapt
         * tool. This integer encodes the package, type, and resource
         * entry. The value 0 is an invalid identifier.
         * @return A color state list, or `null` if the resource could not be
         * resolved.
         * @throws android.content.res.Resources.NotFoundException if the given ID
         * does not exist.
         */
        fun getColorStateList(
            context: Context,
            @ColorRes id: Int
        ): ColorStateList? {
            return if (Build.VERSION.SDK_INT >= 23) {
                context.getColorStateList(id)
            } else {
                context.resources.getColorStateList(id)
            }
        }

        /**
         * Returns a color associated with a particular resource ID
         *
         *
         * Starting in [android.os.Build.VERSION_CODES.M], the returned
         * color will be styled for the specified Context's theme.
         *
         * @param id The desired resource identifier, as generated by the aapt
         * tool. This integer encodes the package, type, and resource
         * entry. The value 0 is an invalid identifier.
         * @return A single color value in the form 0xAARRGGBB.
         * @throws android.content.res.Resources.NotFoundException if the given ID
         * does not exist.
         */
        @ColorInt
        fun getColor(context: Context, @ColorRes id: Int): Int {
            return if (Build.VERSION.SDK_INT >= 23) {
                context.getColor(id)
            } else {
                context.resources.getColor(id)
            }
        }

        /**
         * Determine whether *you* have been granted a particular permission.
         *
         * @param permission The name of the permission being checked.
         *
         * @return [android.content.pm.PackageManager.PERMISSION_GRANTED] if you have the
         * permission, or [android.content.pm.PackageManager.PERMISSION_DENIED] if not.
         *
         * @see android.content.pm.PackageManager.checkPermission
         */
        fun checkSelfPermission(context: Context, permission: String): Int {
            requireNotNull(permission) { "permission is null" }
            return context.checkPermission(permission, Process.myPid(), Process.myUid())
        }

        /**
         * Returns the absolute path to the directory on the filesystem similar to
         * [Context.getFilesDir].  The difference is that files placed under this
         * directory will be excluded from automatic backup to remote storage on
         * devices running [android.os.Build.VERSION_CODES.LOLLIPOP] or later.
         *
         *
         * No permissions are required to read or write to the returned path, since this
         * path is internal storage.
         *
         * @return The path of the directory holding application files that will not be
         * automatically backed up to remote storage.
         *
         * @see android.content.Context.getFilesDir
         */
        fun getNoBackupFilesDir(context: Context): File? {
            return if (Build.VERSION.SDK_INT >= 21) {
                context.noBackupFilesDir
            } else {
                val appInfo = context.applicationInfo
                createFilesDir(File(appInfo.dataDir, "no_backup"))
            }
        }

        /**
         * Returns the absolute path to the application specific cache directory on
         * the filesystem designed for storing cached code. On devices running
         * [android.os.Build.VERSION_CODES.LOLLIPOP] or later, the system will delete
         * any files stored in this location both when your specific application is
         * upgraded, and when the entire platform is upgraded.
         *
         *
         * This location is optimal for storing compiled or optimized code generated
         * by your application at runtime.
         *
         *
         * Apps require no extra permissions to read or write to the returned path,
         * since this path lives in their private storage.
         *
         * @return The path of the directory holding application code cache files.
         */
        fun getCodeCacheDir(context: Context): File? {
            return if (Build.VERSION.SDK_INT >= 21) {
                context.codeCacheDir
            } else {
                val appInfo = context.applicationInfo
                createFilesDir(File(appInfo.dataDir, "code_cache"))
            }
        }

        @Synchronized
        private fun createFilesDir(file: File): File? {
            if (!file.exists()) {
                if (!file.mkdirs()) {
                    if (file.exists()) {
                        // spurious failure; probably racing with another process for this app
                        return file
                    }
                    Log.w(TAG, "Unable to create files subdir " + file.path)
                    return null
                }
            }
            return file
        }

        /**
         * Return a new Context object for the current Context but whose storage
         * APIs are backed by device-protected storage.
         *
         *
         * On devices with direct boot, data stored in this location is encrypted
         * with a key tied to the physical device, and it can be accessed
         * immediately after the device has booted successfully, both
         * *before and after* the user has authenticated with their
         * credentials (such as a lock pattern or PIN).
         *
         *
         * Because device-protected data is available without user authentication,
         * you should carefully limit the data you store using this Context. For
         * example, storing sensitive authentication tokens or passwords in the
         * device-protected area is strongly discouraged.
         *
         *
         * If the underlying device does not have the ability to store
         * device-protected and credential-protected data using different keys, then
         * both storage areas will become available at the same time. They remain as
         * two distinct storage locations on disk, and only the window of
         * availability changes.
         *
         *
         * Each call to this method returns a new instance of a Context object;
         * Context objects are not shared, however common state (ClassLoader, other
         * Resources for the same configuration) may be so the Context itself can be
         * fairly lightweight.
         *
         *
         * Prior to API 24 this method returns
         * `null`, since device-protected storage is not available.
         *
         * @see ContextCompat.isDeviceProtectedStorage
         */
        fun createDeviceProtectedStorageContext(context: Context): Context? {
            return if (Build.VERSION.SDK_INT >= 24) {
                context.createDeviceProtectedStorageContext()
            } else {
                null
            }
        }

        /**
         * Indicates if the storage APIs of this Context are backed by
         * device-encrypted storage.
         *
         * @see ContextCompat.createDeviceProtectedStorageContext
         */
        fun isDeviceProtectedStorage(context: Context): Boolean {
            return if (Build.VERSION.SDK_INT >= 24) {
                context.isDeviceProtectedStorage
            } else {
                false
            }
        }

        /**
         * Return an [Executor] that will run enqueued tasks on the main
         * thread associated with this context. This is the thread used to dispatch
         * calls to application components (activities, services, etc).
         */


        /**
         * startForegroundService() was introduced in O, just call startService
         * for before O.
         *
         * @param context Context to start Service from.
         * @param intent The description of the Service to start.
         *
         * @see Context.startForegroundService
         * @see Context.startService
         */
        fun startForegroundService(context: Context, intent: Intent) {
            if (Build.VERSION.SDK_INT >= 26) {
                context.startForegroundService(intent)
            } else {
                // Pre-O behavior.
                context.startService(intent)
            }
        }


    }
}
